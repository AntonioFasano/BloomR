

# BloomR main functions

## TODO
Complete help for functions br.try.date, br.is.same.class, br.bdh
When in br.desc 'CIE_DES_BULK' is not availbale use NA
allow br.desc/br.bulk.desc to use simulated
Find a better place for  br.beta(): here it does not make sense. In bloomr.Rmd prevents a replacement with the beta when it is ready for shipping. 
Use safer way to get internal variables `get(".br.types", pos = "bloomr")`
Fix XXXX paragraphs
For final tests (when beta is release candidate), do not use source('bloomr.R')

### Terminal tests  
copy of br.desc for simulations
always.display.tickers, dates.as.row.names 



```{r setup, purl=FALSE, include=FALSE}
##rm(list=ls(all=TRUE))

### Shortcuts
opts_chunk$set(echo=TRUE)
OTS=opts_template$set
## Build function first
OTS(purlme=   list(purl=TRUE,  eval=!step2,   include=FALSE))
## Demos running after function building  
OTS(demofull= list(purl=FALSE, eval=step2,  include=TRUE))  # run w/ code + out   
OTS(demorun=  list(purl=FALSE, eval=step2,  include=TRUE, echo=FALSE)) # run w/ out, no code 
OTS(demodry=  list(purl=FALSE, eval=step2,  include=FALSE)) # run only (no code/out)
OTS(democode= list(purl=FALSE, eval=FALSE,  include=TRUE))  # show code only, no run  

## Purl hook
hook_purl=function (before, options, envir) 
{
    .knitEnv=knitr:::.knitEnv
    isFALSE=knitr:::isFALSE
    label_code=knitr:::label_code
    
    if (before || !options$purl || options$engine != "R") 
        return()
    output = .knitEnv$tangle.file
    if (isFALSE(.knitEnv$tangle.start)) {
        .knitEnv$tangle.start = TRUE
        unlink(output)
    }
    code = options$code
    #if (isFALSE(options$eval)) 
       ## code = comment_out(code, "# ", newline = FALSE)
    if (is.character(output)) {
        cat(label_code(code, options$params.src), file = output, 
            sep = "\n", append = TRUE)
    }
}
knit_hooks$set(purl = hook_purl)

```

```{r betaonly, purl=FALSE, eval=!step2,  include=FALSE}

## Calling bloomr.R is necessary to run examples requiring functions not yet present here.
if(grepl("^bloomr\\.beta\\.", current_input()))
    source("bloomr.R")

```

```{r store, opts.label='purlme'}
## Purl this first
## Store br.* objects in bloomr env in base namespace
assign('bloomr',  new.env(parent=asNamespace("base")), envir=asNamespace("base"))

## func: store(func);  var: store("var")
store=function(sym){
    if(is.function(sym)){
        name=deparse(substitute(sym)) 
        val=sym
    } else {
        name=sym
        val=get(sym)
    }
    
    assign(name, val, envir=bloomr)
    rm( list=name, envir=parent.frame())
}

```

br.bdh{#br.bdh}
===============
*Historical data*

XXXXRemove always.display.ticker, dates.as.row.names?
XXXXCheck only  only.trading.days description
XXXXMove staff in auto args

Description
-----------
Download historical Bloomberg data 

Usage
-----
    br.bdh=function(con, security, fields="PX_LAST", start.date=Sys.Date() - 7, end.date=Sys.Date(), 
    override_fields= NULL, override_values=NULL, 
    option.names = NULL, option.values = NULL,
    only.trading.days = TRUE
    )     

Arguments
---------
con
:   the connection token returned from br.open()

securities
:   character vector of the tickers queried for data  

field
:   case insensitive character vector of the Bloomberg field queried. Defaults to "PX_LAST". 

start.date
:   Time series start date as a Date object or an ISO string without separators (YYYYMMDD). Time series will actually begin at `start.date` if there is data available; otherwise it will start at the first significant date. 

end.date
:   Time series end  date as a Date object or an ISO string without separators (YYYYMMDD). If NULL or missing, it defaults to the last available date. 

option.names, option.values
:   See details

always.display.tickers 
:   (removed) Displays tickers in first column even if a single one is requested. Defaults to FALSE

dates.as.row.names  
:   (removed) Displays dates _also_ as row names. Defaults to TRUE for single ticker query, FALSE otherwise. 

only.trading.days
:   If FALSE, rows are returned for all requested dates, even when no markets data is available.  
XXXXCheck! It defaults to FALSE for a single security or and TRUE for multiple securities. In the latter case, use `na.omit`  or `na.exclude` to remove these rows.


Details
-------
For multi-ticker queries you might consider to use `br.hist()` which features also a simulated mode.

`option.names` and `option.values` are options vectors affecting the returned data. Options are set pairwise, for example to set `opt1` and `opt2`  respectively to `val1` and `val2`, you would pass the arguments:

    option.names=c("opt1", "opt2"), option.values=c("val1", "val2")

Here is a list of options:



periodicityAdjustment
:   Determine the frequency and calendar type of the output. To be used in conjunction with `periodicitySelection`. If `ACTUAL`, it  reverts to the actual date from today (if the end date is left blank) 
or from the End Date. If `CALENDAR`, (for pricing fields), it  reverts to the last business day of the specified calendar period. Calendar Quarterly (CQ), Calendar Semi-Annually (CS), or Calendar Yearly (CY). If `FISCAL`, it reverts to the fiscal period end for the company - Fiscal Quarterly (FQ), Fiscal Semi-Annually (FS) and Fiscal Yearly (FY) only.

periodicitySelection
:   Determine the frequency of the output. To be used in conjunction with periodicityAdjustment.
if `DAILY`, `WEEKLY`, `MONTHLY`, `QUARTERLY`, `SEMI_ANNUALLY`, `YEARLY`.

currency
:   Amends the value from local to desired currency. The value is a 3 letter ISO code string, e.g. USD, GBP. View `WCV<GO>` on the Bloomberg terminal for the full list.

overrideOption
:   Indicates whether to use the average or the closing price in quote calculation. Values can be 
`OVERRIDE_OPTION_CLOSE` for using the closing price or `OVERRIDE_OPTION_GPA`  for the average price.

pricingOption
:   Sets quote to Price or Yield for a debt instrument whose default value is quoted in yield (depending on pricing source).
`PRICING_OPTION_PRICE` sets quote to price; `PRICING_OPTION_YIELD` sets quote to yield.

nonTradingDayFillOption 
:   Sets to include/exclude non trading days where no data was generated.
`NON_TRADING_WEEKDAYS` includes all weekdays (Monday to Friday); `ALL_CALENDAR_DAYS`  includes all days of the calendar; `ACTIVE_DAYS_ONLY`  includes only the days where the instrument and field pair 
were updated.


nonTradingDayFillMethod
:   If data is to be displayed for non trading days what is the data to be returned.
 `PREVIOUS_VALUE` searches back and retrieve the previous value available for this security field pair. The search back period is up to one month. `NIL_VALUE` returns blank for the "value" value 
within the data element for this field.

maxDataPoints
:   the maximum number of data points to return. If the original data set is larger, the response will be a subset, containing only the last `maxDataPoints` data points.

returnEids
:   returns the entitlement identifiers associated with security. If TRUE, populates data with an extra element containing a name and value for the EID date.

returnRelativeDate
:   returns data with a relative date. If TRUE, populates data with an extra element containing a name and value for the relative date. For example RELATIVE_DATE = 2002 Q2

adjustmentNormal
:   Adjust for "change on day". If TRUE, adjusts historical pricing to reflect: Regular Cash, Interim, 1st Interim, 2nd Interim, 3rd Interim, 4th Interim, 5th Interim, Income, Estimated, Partnership Distribution, Final, Interest on Capital, Distribution, Prorated.

adjustmentAbnormal 
:   Adjusts for Anormal Cash Dividends. If TRUE, adjusts historical pricing to reflect: Special Cash, Liquidation, Capital Gains, Long-Term Capital Gains, Short-Term Capital Gains, Memorial, Return of Capital, Rights Redemption, Miscellaneous, Return Premium, Preferred Rights Redemption, Proceeds/Rights, Proceeds/Shares, Proceeds/Warrants.


adjustmentSplit
:   Capital Changes Defaults. If TRUE, adjusts historical pricing and/or volume to reflect: Spin-Offs, Stock Splits/Consolidations, Stock Dividend/Bonus, Rights Offerings/Entitlement.

adjustmentFollowDPDF
:   If TRUE (defaults) Follow the Bloomberg function as from `DPDF<GO>`.

CalendarCodeOverride
:   Returns the data based on the calendar of the specified country, exchange, or 
religion. Value is  a two character calendar code as from `CDR<GO>`. This will cause the data to be aligned according to the calendar  and including calendar holidays. Only applies only to DAILY requests.

calendarOverridesInfo
:   (Experimental, not tested) Returns data based on the calendar code of multiple countries, exchanges, or religious calendars as from `CDR<GO>`. This will cause the data to be aligned according to the set calendar(s) including their calendar holidays and only applies to DAILY requests.
Requires `calendarOverrides`, which is a character vector of  two-character calendar codes as from `CDR<GO>`; `calendareOverridesOperation`, which can be  `CDR_AND`  returning  the intersection of trading days among multiple calendars or  `CDR_OR` returning the union of trading days. That is, a data point is returned if a date is a valid trading day for any of the calendar codes specified in the request.

Overrides
:   (Experimental, not tested) Append overrides to modify the calculation. `fieldID` specifies  a field mnemonic or alpha-numeric, such as `PR092` or `PRICING_SOURCE`. Review FLDS<GO> for list of possible overrides. `value` sets the desired override value



Value
-----
A data frame with historical data. If tickers are displayed, the first column shows tickers, the second one the time series dates and the following ones the values of the queried fields; otherwise the columns start with dates. Dates will also be shown as rows if `dates.as.row.names=TRUE`. If multiple tickers are queried, they are vertically stacked respecting the order in `securities` vector.


```{r br.bdh, opts.label='purlme'}
br.bdh=function(
                con, security, fields="PX_LAST",
                start.date=Sys.Date() - 7, end.date=Sys.Date(), 
                override_fields  = NULL, override_values = NULL,               
                option.names = NULL, option.values = NULL,
                only.trading.days = TRUE
                ) {
    
    if(is.null(con)) stop("'con' is NULL, but br.bdh() does not support simulated mode.")


    ## Set overrides
    if(is.null(override_fields)) {
        override_fields="IGNORE"
        override_values = ""
    }

    ## Test/set dates
    dates=.br.test.dates(start.date, end.date, asChar=TRUE)
    option.names=c(option.names, "startDate")
    option.values=c(option.values, dates$start)
    if(!is.null(end.date)) {
        option.names = c(option.names, "endDate")
        option.values = c(option.values, dates$end)
    }


    ## Non trading days
    if(!only.trading.days) {
        option.names=c("nonTradingDayFillOption", "nonTradingDayFillMethod", option.names)
        option.values=c("ALL_CALENDAR_DAYS", "NIL_VALUE", option.values)
    }

    ## Get reference data
    ref=con$blh(security, .jarray(fields),
            .jarray(override_fields), .jarray(override_values),
            .jarray(option.names), .jarray(option.values))
    ret=ref$getData()   
    ret=if(!is.null(ret)) .jevalArray(ret, simplify=TRUE) else ret

    ## Set data attributes
    if(!is.null(ret)) attr(ret, "types")=ref$getDataTypes()
    ## For info on data types Rbbg:::convert.to.type
    ## Consider also ref$getColumnNames()

    ret
}
store(br.bdh)
```

br.hist.csv{#br.hist.csv}
========================
*Historical data from grouped tickers in a CSV file*  
Reads a CSV file containing a group of tickers in each column and returns the historical data in xts or list format. The CSV file is assumed to have headers denoting group labels. 
It replaces `br.bulk.csv``

Usage
------
    br.hist.csv(con, file, field="PX_LAST", start=Sys.Date()-5, end.date=Sys.Date(),

                     cols=NULL, comma=TRUE,
                     addtype=FALSE, showtype=FALSE,  
                     use.xts=TRUE, merge.xts=TRUE,

                     option.names = NULL, option.values = NULL,
                     only.trading.days = TRUE,

                     price=TRUE,
                     mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                     same.dates=FALSE, empty.sec=0,
                     weekend=TRUE, holidays=NULL)


  
Arguments
----------

#' @args

price, mean, sd, jitter, same.dates, empty.sec, weekend, holidays
:   arguments passed to `br.sample()` if `con=NULL`.

Details
-------
Empty CSV cells or cells interpreted as NAs will be ignored.  
If `con=NULL`, values are simulated by means of `br.sample()`. This function is used with default values, except for `start, end.date, price, mean, sd, jitter, same.dates, empty.sec, weekend, holidays`, which can be explicitly passed as arguments, and `sec.names` depending on tickers found in the CSV file. These arguments are ignored if `con!=NULL`. See `br.sample()` help for more.

Value
-----
a list where each element is the historical data of a CSV group.  
If `use.xts=TRUE` and `merge.xts=FAlSE`, each group is a sub-list, whose elements are the the securoty time series as an xts object.
If `use.xts=TRUE` and `merge.xts=TRUE`, each group is the merged xts object, obtained merging historical data of all securities of that group.
If `use.xts=FALSE`, each group is a sub-list, where each element is the historical data of a security as a data frame.  
If there is only one group, the first (and unique) element of the list will be returned (XXXXto check).  


```{r br.hist.csv, opts.label='purlme'}
br.hist.csv=function(
                     #' the connection token returned from br.open().
                     #' If `NULL` simulated values are generated.   
                     con,
                     file, #' path to CSV file.

                     #' case insensitive string denoting the Bloomberg field queried. Defaults to "PX_LAST".
                     #' If the field is wrong or not accessible, data will be empty,
                     #' but no error will be raised.
                     field="PX_LAST",

                     #' start date. Can be a Date object or an ISO string without separators (YYYYMMDD).
                     #' Defaults to 5 days before current date.  
                     start=Sys.Date()-5,
                    
                     end.date=Sys.Date(), #' end date. Same format as `start`. Defaults to current date.  

                     #' Logical or integer vector for selecting CSV columns (ticker groups).
                     #' Defaults to all columns.  
                     cols=NULL,

                     #' to be set to FALSE for (non-English) CSV, using semicolon as separator.  
                     comma=TRUE,

                     #'  If a string, it denotes the security type and is added to all tickers;
                     #' if TRUE "Equity", will be added; if FALSE (the default), nothing will be added.  
                     addtype=FALSE,

                     #' if TRUE, security types will be removed from names of list or xts output.
                     #' It defaults to FALSE.  
                     showtype=FALSE,

                     #' if TRUE (the default) time series are formatted as xts objects.
                     #' else as a data frame.  
                     use.xts=TRUE,
                     
                     #' if TRUE (the default) xts objects in the same group are merged using all rows and
                     #' using NAs for missing observations.
                     merge.xts=TRUE,

                     ## br.bdh args
                     #' list of Bloomberg options names. Require `option.values` too.
                     option.names = NULL,
                     #' list of Bloomberg options values related to `option.names`.
                     option.values = NULL,

                     #' if TRUE (the default) only trading days are used,
                     #' else non-trading days are added as NA values. 
                     only.trading.days = TRUE,

                     ## Simulation args                      
                     price=TRUE,
                     mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                     same.dates=FALSE, empty.sec=0,
                     weekend=TRUE, holidays=NULL)
{

    ## Check csv file
    if(!file.exists(file)) stop(paste('Unable to find the csv file', file))
    if(comma) csv=read.csv(file=file, as.is=TRUE) else{
        csv=read.csv2(file=file, as.is=TRUE)}

    ## Check cols arg
    if(!is.null(cols)){
        if(is.logical(cols) && !length(cols)==ncol(csv))
            stop(paste('Length of logical vector', paste(cols, collapse=' '),
                       'not equal to number of groups in', file))

        if(is.integer(cols) && max(cols)>ncol(csv))
            stop(paste('Unable to subset groups in', file, 'with columns', paste(cols, collapse=' ')))

        if(!is.logical(cols) && !all(cols%%1==0)) stop(paste(
         "'Col argument should be an integer or a logical vector of the same length of the groups in", file))
        csv=csv[cols]        
    }

    ## Get group names and count
    gnams=names(csv)
    gcnt=ncol(csv)

    ## Loop groups in csv
    grps=list()
    for(g in 1:gcnt){
        message('Processing ', gnams[g],  ' ...')
        x=list(br.hist(
            con=con, tiks=csv[[g]], field=field, start=start, end.date=end.date,
            
            addtype=addtype, showtype=showtype,
            use.xts=use.xts, merge.xts=merge.xts,
            
            option.names=option.names, option.values=option.values,
            only.trading.days=only.trading.days,
            
            price=price, same.dates=same.dates, empty.sec=empty.sec,
            weekend=weekend, holidays=holidays))
        
        names(x)=gnams[g]
        grps=c(grps, x)        
    }
    if(length(grps)==1) grps=grps[[1]]
    grps
}

store(br.hist.csv)

```

Demonstration
-------------


A sample CSV with Bloomberg tickers will look like follows:


```{r br.hist.csv.demo1.show, opts.label='democode'}
read.csv("mybloomr/tickers.csv")
## This file is part of BloomR and anyway available here:
## https://github.com/AntonioFasano/BloomR/blob/master/res/tickers.csv
```

```{r br.hist.csv.demo1, opts.label='demorun'}
read.csv("../res/tickers.csv")
```


Note: 

* CSV group headers are mandatory;
* Group headers need not to be the same length. 

We can now download data:

```{r br.hist.csv.demo2, opts.label='demofull'}
con=NULL  #Simulated mode: replace with con=br.open() on terminal
```

```{r br.hist.csv.demo3.show, opts.label='democode'}
data=br.hist.csv(con, "mybloomr/tickers.csv") 
```

```{r br.hist.csv.demo3, opts.label='demorun'}
data=br.hist.csv(con, "../res/tickers.csv")
```


Above you see some info about data being processed that we will not show anymore in the following.

If you want to have detailed ticker descriptions,  see [br.bulk.desc Example](#br.bulk.desc.exem). Downloaded data look like follows:

```{r br.hist.csv.demo4, opts.label='demofull'}
data
```

Note:

* The name of the securities tickers is stored without the security type: "Equity", "Index", etc.  
If this piece of info is significant for you, pass `showtype = TRUE`.   

* Time series start date defaults to 5 days before current date, unless you set `start` to: 
an R Date object (`start=as.Date("2014/9/30")`) or to a  more friendly ISO string (`start="20140930")`).     

Data are stored as a list of xts objects, each representing one group of tickers in the CSV file.


```{r br.hist.csv.demo5, opts.label='demofull'}
length(data)
names(data)
class(data$Financial)
```

If you prefer you may get time series as data frames, and precisely as a list representing the ticker groups, where each group is in turn a list containing a data frame for each security:

```{r br.hist.csv.demo6.q, opts.label='demodry'}
data=br.hist.csv(con, "../res/tickers.csv", use.xts=FALSE) 
```
```{r br.hist.csv.demo6.show, opts.label='democode'}
data=br.hist.csv(con, "mybloomr/tickers.csv", use.xts=FALSE) 
```

```{r br.hist.csv.demo7, opts.label='demofull'}
length(data)
names(data)
class(data$Financial)
length(data$Financial)
names(data$Financial)
class(data$Financial$`BAC US`)
```

By defaults time series list values from the Bloomberg "PX_LAST" field. To change the default field use:

```{r br.hist.csv.demo8.show, opts.label='democode'}
data=br.hist.csv(con, "mybloomr/tickers.csv", field = "PX_OPEN") 
```


You can choose to import only some of the CSV groups 

```{r br.hist.csv.demo9, opts.label='demorun'}
data=br.hist.csv(con, "../res/tickers.csv", cols=c(1,3))
```

```{r br.hist.csv.demo9.show, opts.label='democode'}
data=br.hist.csv(con, "mybloomr/tickers.csv", cols=c(1,3))
## or equivalently:
data=br.hist.csv(con, "mybloomr/tickers.csv", cols=c(TRUE, FALSE, TRUE))
```

```{r br.hist.csv.demo10, opts.label='demofull'}
names(data)
```
 
In the CSV file, if your tickers represent all equities, you can omit the type.   

Consider this CSV:

```{r br.hist.csv.demo11.show, opts.label='democode'}
read.csv("mybloomr/tickers.eqt.csv")
## This file is part of BloomR and anyway available here:
## https://github.com/AntonioFasano/BloomR/blob/master/res/tickers.eqt.csv
```

```{r br.hist.csv.demo11, opts.label='demorun'}
read.csv("../res/tickers.eqt.csv")
```

Note how the "Equity" type is missing! But you can use this CSV file with `addtype`:

```{r br.hist.csv.demo12.q, opts.label='demodry'}
data=br.hist.csv(con, "../res/tickers.eqt.csv", addtype=TRUE)
```

```{r br.hist.csv.demo12.show, opts.label='democode'}
data=br.hist.csv(con, "mybloomr/tickers.eqt.csv", addtype=TRUE)
```

Before _going home_, don't forget to:

```{r br.hist.csv.demo13, opts.label='demofull'}
br.close(con)
```


br.bulk.desc{#br.bulk.desc}
===========================

Description
-----------
Get security descriptions for a vector of tickers.

Usage
-----
    br.bulk.desc(con, tiks) 

Arguments
---------
con
:    the connection token returned from br.open()  

tiks
:    character vector of the tickers queried for data  

Value
-----
A list of data frames, each representing the description of a security. For the format of data frames see the function `br.desc`.


```{r br.bulk.desc, opts.label='purlme'}
br.bulk.desc=function(con, tiks) {

    LL = lapply(tiks, function(tik){
        message('Reading ', tik)
        br.desc(con, tik)             
    })
    names(LL)=tiks
    LL
}
store(br.bulk.desc)
```

Example{#br.bulk.desc.exam}
----------------------------

```{r br.bulk.desc.exam.show,  opts.label='democode'}
con=br.open()
data=read.csv("mybloomr/tickers.csv", as.is=TRUE)
br.bulk.desc(con, as.vector(as.matrix(data[1:2,])))
br.close(con)
```


br.idx{#br.idx}
===============

Description
-----------
Returns the historical data for the constituents of an index in xts or list format.
It replaces `br.bulk.idx`.

Usage
-----
    br.idx(con, index, field="PX_LAST", start=Sys.Date()-7, end.date=Sys.Date(),

                include.idx=TRUE, showtype=FALSE,
                use.xts=TRUE, merge.xts=TRUE,

                option.names = NULL, option.values = NULL,
                only.trading.days = TRUE,

                nsec=10, sec.names = NULL,
                
                price=TRUE,
                mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                same.dates=FALSE, empty.sec=0,
                weekend=TRUE, holidays=NULL)
				

Arguments
---------
con
:   the connection token returned from br.open(). If `NULL` simulated values are generated.   

index
:   string denoting the index ticker with or without the final security type label ('Index')  

include.idx
:   if TRUE (default) returns also historical data for the index.  

nsec
:   number of simulated index constituents. Ignored if `con!=NULL`, it defaults to 10.  

sec.names
:   character vector with names of sampled index constituents. Ignored if `con!=NULL`. By default security names are like 'memb1', 'memb2', etc.

For other arguments see the function `br.hist`.

Details
-------
If `con=NULL`,  values are simulated by means of `br.sample()`. This function is used with default values, except for `nrow, nsec1, price, start, same.dates, no.na, empty.sec, sec.names`.

Value
-----

If `use.xts=FALSE`, a list where each element is the historical data of a constituent as a data frame.  
If `use.xts=TRUE` and `merge.xts=FAlSE`, a list where each element is the historical data of a constituent  as an xts object.  
If `use.xts=TRUE` and `merge.xts=TRUE`, an xts oject where where each column is the historical data of a constituent .   
If `include.idx=TRUE`, the last column or element will be the historical data of the index.  



```{r br.idx, opts.label='purlme'}
br.idx=function(con, index, field="PX_LAST", start=Sys.Date()-7, end.date=Sys.Date(),

                include.idx=TRUE, showtype=FALSE,
                use.xts=TRUE, merge.xts=TRUE,

                ## br.bdh args
                option.names = NULL, option.values = NULL,
                only.trading.days = TRUE,

                ## Simulation args                                      
                nsec=10, sec.names = NULL,
                
                price=TRUE,
                mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                same.dates=FALSE, empty.sec=0,
                weekend=TRUE, holidays=NULL)
{   
    ## Check connection
    if(!is.null(con) && !.br.is.con(con)) stop('Invalid connection parameter')

    ## Check index format. Add 'INDEX' if missing
    if(!is.character(index)) stop('Index should be a string')
    if(length(index)>1) stop('Only one index')
    if(!grepl("INDEX$", toupper(index))) index=paste(index, 'INDEX') 

    ## Get index members
    if(is.null(con)) tiks=paste0('memb', 1:nsec) else{
        tiks=bds(con, index, 'INDX_MEMBERS')
        tiks=paste(tiks[[1]], 'Equity')
    }

    ## Check sec.names
    if(is.null(con) && !is.null(sec.names)) {
        if(!is.character(sec.names)) stop("'sec.names' should be a character vector")
        if(length(sec.names)!=nsec)
            stop("'sec.names' length should be equal to the number of index constituents")
        tiks=sec.names
    }
    
    ## Include index?
    if(include.idx) tiks=c(index, tiks)

    ## Get data
    br.hist(con=con, tiks=tiks, field=field, start=start, end.date=end.date,
        
            addtype=FALSE, showtype=showtype,
            use.xts=TRUE, merge.xts=TRUE,
        
            option.names=option.names, option.values=option.values,
            only.trading.days=only.trading.days,

            price=TRUE,
            mean=mean, sd=sd, jitter=jitter,
            same.dates=same.dates, empty.sec=empty.sec,
            weekend=TRUE, holidays=NULL)       
}

store(br.idx)

```


br.hist{#br.hist}
==================
*Historical data for vector of tickers*  
Returns the historical data for a vector of tickers in xts or list format.
It replaces `br.bulk.tiks``

Usage
------
    br.hist(con, tiks, field="PX_LAST", start=Sys.Date()-7, end.date=Sys.Date(),
                                            
                 addtype=FALSE, showtype=FALSE,                      
                 use.xts=TRUE, merge.xts=TRUE,
                 
                 option.names = NULL, option.values = NULL,
                 only.trading.days = TRUE,

                 price=TRUE,
                 mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                 same.dates=FALSE, empty.sec=0,
                 weekend=TRUE, holidays=NULL)

  
Arguments
----------

#' @args

For other arguments see the function `br.hist.csv`.



Details
-------

If an element of `tiks` is `NA` or empty (`""`) it is ignored. This is intended to avoid errors when the character vector are read from a CSV file with empty cells.  
If `con=NULL`, values are simulated by means of `br.sample()`. Sampled values are based on default values of `br.sample()`, but it is possible to set explicitly  `start, end.date, price, mean, sd, jitter, same.dates, empty.sec, weekend, holidays`; `sec.names` depends on `tiks` argument. These arguments are ignored if `con!=NULL`. See `br.sample()` help for more.


Value
-----
If `use.xts=FALSE`, a list of character matrices, where the first column, named "date", has the observation dates, the second column, named after the field, has field values. The list names are the tickers. 
Empty time series are returned as NULL. If all time series are empty a list of NULLs is returned.

If `use.xts=TRUE` and `merge.xts=FAlSE`, a list of xts objects, where the xts index has the observation dates and its data column, named after the field, has field values. The list names are the tickers. 
Empty time series are returned as NA. If all time series are empty a list of NAs is returned.

If `use.xts=TRUE` and `merge.xts=TRUE`, then when:  
A) There is at least one non-empty TS, an xts object is returned, where the index has the observation dates and columns, named after the tickers, have field values. Empty time series are returned as a NA column for the related xts ticker.
B) All time series are empty a vectors of NAs of the same length as the queries tickers is returned. 


Example
-------

```{r br.hist.exam, opts.label='demofull'}
con=NULL # Open simulated connection and  load some data
br.hist(con, c("MSFT US", "AMZN US"), addtype=TRUE)
br.close(con) # Use the token to release the connection
```

See Also
--------

[br.hist.csv](#br.hist.csv)

```{r br.hist, opts.label='purlme'}
br.hist=function(con,
                 
                 #' character vector of the tickers queried for data
                 tiks, field="PX_LAST", start=Sys.Date()-7, end.date=Sys.Date(),
                                            
                 addtype=FALSE, showtype=FALSE,

                 #' if TRUE (the default) time series are formatted as xts objects else as a data frame.  
                 use.xts=TRUE,

                 #' if TRUE (the default) xts objects are merged using all rows
                 #' and using NAs for missing observations.
                 merge.xts=TRUE,   
                 
                 ## br.bdh args
                 option.names = NULL, option.values = NULL,
                 only.trading.days = TRUE,

                 ## Simulation args                      
                 price=TRUE,
                 mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                 same.dates=FALSE, empty.sec=0,
                 weekend=TRUE, holidays=NULL )
{
    

    ## Check connection
    if(!is.null(con) && !.br.is.con(con)) stop('Invalid connection parameter') 
    
    ## Check tickers (skip possible empty CSV cells)
    if(!is.character(tiks)) stop('Tickers should be in the form of a character vector')
    tiks=tiks[!is.na(tiks)] 
    tiks=tiks[tiks!='']
    
    ## Check security type to add/show
    .br.check.type(addtype)
    .br.check.type(showtype)
    if(addtype==TRUE)  addtype="Equity"
    if(addtype!=FALSE) tiks=paste(tiks, addtype)
    if(!showtype) tiks.show=.br.cuttype(tiks) else tiks.show=tiks
    
    ## Check xts library availability
    if(use.xts && !require("xts", quietly=TRUE, character.only=TRUE)) stop("Can't find library xts")
 
    ## Check empty.sec is a ratio
    if(empty.sec<0 || empty.sec>1) stop("'empty.sec' must be between 0 and 1")
    
    ## br.bdh() and sample() pars
    bdhpars=list(
        con=con, field=field, start.date=start, end.date=end.date, 
        option.names=option.names, option.values=option.values,
        only.trading.days=only.trading.days)
    
    sampars=list(nrow=NULL, price=price, start=start, end.date=end.date, 
                 field=field,
                 use.xts=FALSE,
                 mean=mean, sd=sd, jitter=jitter,
                 rand.dates=!same.dates,                 
                 weekend=weekend, holidays=holidays)

    
    #emptydf=structure(list(date = logical(0), PX_LAST = logical(0)),
    #                  .Names = c("date", toupper(field)), row.names = integer(0), class = "data.frame")

    
    ## Get data as list of matrices
    LL=lapply(tiks, function(tik){
        message('Loading ', tik)
        if(is.null(con)) do.call("br.sample", sampars)
          else do.call("br.bdh", c(security=tik, bdhpars))        
    })

    ## Randomly identify empty.sec
    if(is.null(con)){        
        x=round(length(tiks.show) * empty.sec)
        empty=sample(length(tiks.show), x)
        LL[empty]=rep(list(NULL), x)
    }
        
    ## Convert matrices to XTS's
    if(use.xts){
        LL = lapply(LL, function(ts) {
            if(!is.null(ts)) setNames(xts(as.numeric(ts[,-1]), as.Date(ts[,1])), toupper(field)) else NA
        })
    }
    
    ## Merge XTS's
    if(use.xts && merge.xts){
        ## If there are only NAs, output NULL
        LL=if(all(is.na(LL))) unlist(LL)
           else 
               if(length(LL)>1) do.call("merge.xts", LL) else LL[[1]]
    }

    ## Return with ticker's names
    setNames(LL, tiks.show)
        
    ## Zero-rows xts
    ## In the future we can consider to use zero rows xts instead of NAs
    ## To convert LL=list(NA, NA, ...)-> empty xts: xts(t(unlist(LL)), Sys.Date())[-1]
    ## To set names for zero-rows xts:  dimnames(zero_xts)= list(NULL,names)
    ## Currently zero-rows xts's do not play with merge.xts, which should be redefined 
  
}

store(br.hist)

```


br.desc{#br.desc}
================

Description
-----------
Get security descriptions.

Usage
-----
    br.desc(con, tik)

Arguments
---------
con
:   the connection token returned from br.open()  

tik
:   string denoting the ticker queried for data  

Value
-----
A data frame containing the value of the Bloomberg fields form `ds001` to `ds009` and the long field `CIE_DES_BULK`.

```{r br.desc, opts.label='purlme'}
br.desc=function(con, tik)
{

    ## Check connection
    if(!.br.is.con(con)) stop('Invalid connection parameter') 

    ## Check ticker format
    if(!is.character(tik)) stop('The ticker should be a string')
    if(length(tik)>1) stop('Only one  ticker')
       
    ## Short description fields as data frame
    des=paste0('ds00', 1:9)
    des=des[-7] # not usually working 
    x=bdp(con, tik, des)
    x=data.frame(t(x), stringsAsFactors=FALSE)

    ## Long description field
    xx=bds(con, tik, 'CIE_DES_BULK')

    ## Merge fields add long desc to DF
    if(!is.null(xx)) colnames(xx) = colnames(x)
    rnams=c(rownames(x), rownames(xx))
    x=rbind(x,xx)
    rownames(x)=rnams
    x
}
store(br.desc)
```


br.md2pdf{#br.md2pdf} 
=====================

Description
-----------
Make a markdown file into a PDF
It assumes that you have installed the BloomR LaTeX addons

Usage
-----
    br.md2pdf(md.file, pdf.file)

Arguments
---------
md.file
:   path to the markdown file to be converted.  

pdf.file
:   path to the PDF file to be generated.  

Details
-------
The function will stop with an error if you have not installed BloomR LaTeX addons. To install them use `br.getLatexAddons()`.

Value
-----
If there are no errors, it returns zero invisibly, otherwise it prints an error message and returns the related error code.


```{r br.md2pdf, opts.label='purlme'}

br.md2pdf=function(md.file, pdf.file){
### Make a markdown file into a PDF
## It assumes that you have installed the BloomR LaTeX addons

    ## Set pandoc and LaTeX exe and dir 
    panexe=dbr.brmain("pandoc/bin/pandoc.exe")
    if(!file.exists(panexe))
        stop(paste("Unable to find:", panexe, '\nDid you install BloomR LaTeX addons?'))
    latbin=dbr.brmain("latex/miktex/bin")
    if(!file.exists(latbin))
        stop(paste("Unable to find:", latbin, '\nDid you install BloomR LaTeX addons?'))

    ## Shell escape
    panexe=.br.wpath(panexe)

    ## Set system Path to LaTeX bin
    old.path=Sys.getenv('Path')
    x=paste0(Sys.getenv("Path"), ';', gsub('/', '\\\\',  latbin))
    Sys.setenv(Path=x)

    cmd=paste(panexe, .br.wpath(md.file), '-o', .br.wpath(pdf.file))
    out  <-  system(cmd, intern = TRUE, invisible = FALSE)

    ## Restore origina system Path
    Sys.setenv(Path=old.path)

    ## Return errors if any
    if(!is.null(attr(out, 'status')))  message(paste(out, collapse="\n"))

    invisible(out)

}
store(br.md2pdf)
```


br.sample{#br.sample}
====================

Description
------------
Return simulated historical data for n securities in xts or df format.

Usage
-----
    br.sample(nrow=NULL,  price=TRUE,
                   start=Sys.Date() - 7, end.date=Sys.Date(), 
                   field="FIELD",
                   use.xts=TRUE, 
                   mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                   rand.dates=TRUE, weekend=TRUE, holidays=NULL)
             


Arguments
---------
nrow
:   number of simulated data points for each security; if `same.dates=FALSE`, the number of rows for each sampled security will be a random number not exceeding nrow, else it will be nrow for all securities. Actual number of rows depends on the value of `rand.dates`, `weekend`, `holidays`. 

price
:   if TRUE (default), simulated values are non-negative.  

start
:   start date. Can be a Date object or an ISO string without separators (YYYYMMDD). Defaults to current date.  

end.date
:   end date. Same format as `start`. Defaults to current date.  

field
:   case insensitive string denoting the Bloomberg field queried. Defaults to "FIELD". 

use.xts
:   if TRUE (the default) time series are formatted as xts objects else as a data frame.  

mean
:   mean of security generated values. If `price=TRUE`, default to 10 else defaults to 0.1.  

sd
:   sd of security generated values. It defaults to 1.  

jitter
:   modifies each security mean by adding adding a random value in [-jitter, jitter]. Defaults to 0.  

rand.dates
:   if TRUE, all sampled securities will refer to the same dates and for each security the number will equal nrow. If FALSE (default), date values and number will randomly differ. For each security the random number will not exceed `nrow`.  

weekend
:   if TRUE (default), weekend dates are removed.

holidays
:   list of dates to be removed,


Details 
-------

`br.sample()` assumes by default that data for some securities might not be available on certain days and time series might be misaligned (see "Missing observations and misalignment" in  `br.hist()`), therefore 
the date values and count for each time series generated will randomly differ,  with `nrow` as the maximum number of days. If you want all time series to share tha same dates, set `rand.dates=FALSE`. In this case, time series produced are aligned and you don't see any merge NA, the acutal dates generated depends on the value of `weekend` and `holidays`. If there are no holidays falling in time windows queried and `weekend=FALSE` the number of generated dates equals `nrow`.


Value
-----
If `use.xts=FALSE`, a data frame object, where the first column is the vector with all generated dates merged and each subsequent column contains the sampled data of a security. If `use.xts=TRUE`, an xts object, where each element is the sampled data of a security, while the dates will be part of the xts time object. In both cases if `rand.dates=TRUE` generated data points might likely have different length 

XXXX and the the date gaps will be filled with NAs, except if `no.na=TRUE`. If the generated values are only NAs the output will be converted to a 0-rows xts or data frame, containing only security labels accessible with `dimnames(*)[[2]]`. 

```{r br.sample, opts.label='purlme'}
br.sample=function(nrow=NULL,  price=TRUE,
                   start=Sys.Date() - 7, end.date=Sys.Date(), 
                   field="FIELD",
                   use.xts=TRUE, 
                   mean=ifelse(price, 10, 0.1), sd=1, jitter=0,
                   rand.dates=TRUE, weekend=TRUE, holidays=NULL,
                   nsec=NULL, no.na=NULL, df=NULL, sec.names=NULL, empty.sec=NULL, same.dates=NULL)
{

    ## Deprecated args
    .br.sample.deprecated(nsec, no.na, df, sec.names, empty.sec, same.dates)

    if(!require("xts", quietly=TRUE, character.only=TRUE))  stop("Can't find library xts")
   
    ## Test/set args 
    dates=.br.test.dates(start, end.date, holidays)
    if(is.null(nrow)) nrow=dates$end - dates$start
    nrow=as.numeric(nrow)
      
    ## Jitter 
    mean.jit= mean + runif(1, -jitter, jitter)
    
    ## Generate TS with fixed or random dates
    r= if(rand.dates) sample(1:nrow,1) else nrow 

    ## Generate time series as a DF
    TS=data.frame(d=sort(sample(dates$start+1:nrow-1,r)), f=round(rnorm(r,mean.jit, sd),3))
    if(price) TS$f=abs(TS$f) # Price always non-negative
    names(TS)=c("date", toupper(field))

        
    ## Remove weekends and holidays
    if(weekend){
        w=format(TS$date, "%u")
        TS= TS[w!="6" & w!="7", ]       
    }    
    if(!is.null(holidays)){
         TS=TS[!TS$date %in% holidays, ]       
    }

    ## Convert TSs to XTS's
    TS=as.matrix(TS)
    attr(TS, "types")=c("DATE","FLOAT64")
    if(nrow(TS)==0) TS=NULL

    
        
    ## Convert TSs to XTS's
    if(use.xts){
        TS=if(!is.null(TS)) xts(as.numeric(TS[,-1]), as.Date(TS[,1])) else NA
    }

    TS
}

store(br.sample)

```


Internal BloomR functions{#Internal}
=====================================

Description:
------------
Internal functions not to be used by the end user

Usage:
------

    .br.is.con(con)
    .br.types
    .br.check.type(type) 
    .br.cuttype(type)
    .br.jar()

Arguments:
----------
con
:   the connection token returned from br.open()  

type
:   a string representing the security type  

Details
-------
`.br.is.con` checks for the validity of a connection token.
`.br.types` is a character vector with security types suitable as an argument for BloomR multi-ticker  functions.
`.br.check.type` checks if a type matches `.br.types`.
`.br.cuttype` cuts trailing security type from character vector.
`.br.jar()` returns the path to the blpapi*.jar
`.br.session` object storing BloomR session information. 


```{r bbg-internal, opts.label='purlme'}

## Check connection token
.br.is.con=function(con) identical(attr(con, 'jclass'), "org/findata/blpwrapper/Connection")

## Legal security types
.br.types=c('Govt', 'Corp', 'Mtge', 'M-Mkt', 'Muni', 'Pfd', 'Equity', 'Comdty', 'Index', 'Curncy')

## Check security type
.br.check.type=function(type) {
    if(is.character(type)){
	x=toupper(type)
	xx=toupper(get(".br.types", pos = "bloomr"))
	if(!any(xx %in% x)) stop(paste(x, 'not in', paste(xx, collapse=' ')))
    }
}

## Cut trailing security type from character vector 
.br.cuttype=function(type){
    p=paste0(' +', get(".br.types", pos = "bloomr"), '$|', collapse='')
    p=sub('\\|$', '', p)
    sub(p, '', type, ignore.case=TRUE)
}


.br.jar=function(){
    jarpath=dbr.brmain("/blpapi/bin")
    Sys.glob(file.path(jarpath,  "blpapi-[0-9]*.jar"))
    }

## Legal security types
.br.session=NULL
.br.session$simulated=FALSE 
.br.session$tokenasked=FALSE 
.br.session$tokensuccess=FALSE 

store(.br.is.con)
store(".br.types")
store(.br.check.type) 
store(.br.cuttype)
store(.br.jar)
store(".br.session")

```


Manage connections{#connections}
===============================

Description
------------
Open,close and test the connection to the Bloomberg service.   


Usage
-----
    br.open()
    br.close(con)
    br.simulate(is=TRUE)
    br.is.sim()


Arguments
---------
con
:   the connection token returned from br.open()

is
:   if TRUE (default), simulate connection. 


Details
-------

`br.open` returns the connection token needed by the BloomR function downloading data. When you finish you session, you pass it to `br.close`. If you have run `br.simulate(is=TRUE)`, data are simulated (and your connection token is `NULL`). ` br.is.sim()` tests if the connection is simulated.   
If ` br.is.sim()`, closing the connection is optional. Anyway running `br.close(con)`, even if `con==NULL` avoids adding this line when you switch to a actual data download.


Example
-------

```{r connections.exem, opts.label='democode'}
con=br.open() # Open the connection and get the token and load some data
br.hist(con, c("MSFT US", "AMZN US"), addtype=TRUE)
br.close(con) # Use the token to release the connection

```


```{r connections, opts.label='purlme'}
br.open=function() {

    if(br.is.sim()) return(NULL)

    assign(".br.session$tokenasked", TRUE, pos = "bloomr")
    blpConnect(blpapi.jar.file=.br.jar())
    assign(".br.session$tokensuccess", TRUE, pos = "bloomr")
}

br.close=function(conn) {
    if(!is.null(conn)) blpDisconnect(conn)
    assign(".br.session$tokenasked", FALSE, pos = "bloomr")
    assign(".br.session$tokensuccess", FALSE, pos = "bloomr")
}

br.simulate=function(is=TRUE) {
    assign(".br.session$simulated", is, pos = "bloomr")    
}

br.is.sim=function() {
    get(".br.session$simulated", pos = "bloomr")
}

store(br.open)
store(br.close)
store(br.simulate)
store(br.is.sim)

```


Misc functions{#misc.functions}
==============================

Description
------------
`rm.all` deletes all objects (variables and functions) from memory, including invisible objects (those starting with a dot).
`rm.var` deletes non-function objects from memory.


Usage
-----
	rm.all()
	rm.var()
	

```{r miscfunc, opts.label='purlme'}

#Clean up
## Remove visible and invisible objects
rm.all=function() 
    rm(list=ls(all=TRUE, envir=parent.frame()), envir=parent.frame())

## Remove visible non-function objects
rm.var=function() 
    rm(list=setdiff(ls(envir=parent.frame()), lsf.str(envir=parent.frame())),  envir=parent.frame())

store(rm.all)
store(rm.var)
```


Beta functionalities{#beta.functions}
=====================================

Description
------------
Activate beta functionalities, if available for this release. 

Usage
-----
    br.beta()


```{r betafun, opts.label='purlme'}

br.beta=function(){
    f=paste0(R.home("share"), "/bloomr/bloomr.beta.R")    
    if(file.exists(f)) source(f)  else message("No beta functionalities in this release")
}

store(br.beta)

```

Beta misc functions{#beta.misc.functions}
=========================================

Description
------------

`br.try.date` converts a vector to a date vector if possible or return null. Any vector element should be POSIXlt, POSIXct, Date, "%Y/%m/%d", or "%Y-%m-%d"

`br.is.same.class` check if all supplied argumets have the same class. It is mostly intended to check if dates are homogeneous. 

`.br.test.dates` tests the validity of given start, end date, possibly against a holiday vector.

Usage
-----
    br.try.date(d)
    br.is.same.class(...)
    .br.test.dates(start, end, holidays=NULL, asChar=FALSE)

```{r MISCFUNC, opts.label='purlme'}

br.try.date=function(d){ # convert vector d to a date vector if possible or return null
### Any element should be POSIXlt, POSIXct, Date, "%Y/%m/%d", or "%Y-%m-%d"
                           
    if(identical(class(d), c("POSIXlt", "POSIXt"))) return(d) 
    if(identical(class(d), c("POSIXct", "POSIXt"))) return(d)
    if(identical(class(d), "Date")) return(d)

    if(is.character(d)) {
        
        try=as.Date(d, "%Y%m%d")
        if(!anyNA(try)) return(try)

        try=as.Date(d, "%Y/%m/%d")
        if(!anyNA(try)) return(try)

        try=as.Date(d, "%Y-%m-%d")
        if(!anyNA(try)) return(try)
    }
    
    return(NULL)
}

br.is.same.class=function(...){ # Check if all argumets have the same class
### Mostly intended to check if dates are homogeneous

    L=lapply(list(...), class)
    length(unique(L))==1
}


.br.test.dates=function(start, end, holidays=NULL, asChar=FALSE){

    if(is.null(start <- br.try.date(start)))
        stop(paste('Invalid date', start)) 

    if(is.null(end <- br.try.date(end)))
        stop(paste('Invalid date', end))

    if(!is.null(holidays) &  is.null(holidays <- br.try.date(holidays)))
        stop("Some dates are not recognised: ", paste(holidays, collapse=" "))

    if(!br.is.same.class(c(list(start, end), holidays))){
        message("Start date: ", paste(class(start), collapse=" "))
        message("End date: ", paste(class(end), collapse=" "))
        if(!is.null(holidays))
            message("holidays: ", paste(class(holidays), collapse=" "))
        stop("Not all date variable have the same class")        
    }
    
    if(start>=end) stop("Start date should be set before end date!")

    if(asChar){
        start=format(start, format="%Y%m%d")
        end=format(end, format="%Y%m%d")
    }
    list(start=start, end=end, holidays=holidays)    

}

store(br.try.date)
store(br.is.same.class) 

```

Deprecated functions{#deprecated.functions}
===========================================

Description
------------
Functions (planned to be) deprecated.

Usage
-----
    .br.sample.deprecated(nsec=NULL, no.na=NULL, df=NULL,
                     sec.names=NULL, empty.sec=NULL, same.dates=NULL)

 
Arguments
---------
See current non beta BloomR.


```{r deprecated, opts.label='purlme'}

.br.sample.deprecated=function(nsec=NULL, no.na=NULL, df=NULL,
                               sec.names=NULL, empty.sec=NULL, same.dates=NULL){

    if(!is.null(no.na))
        stop("'no.na' option is now deprecated:",
             " just use rand.dates=TRUE or apply na.omit to br.sample() output.")

    if(!is.null(df))
        stop("'df' option is now deprecated. Use: 'use.xts=FALSE'")
    
    if(!is.null(sec.names))
        stop("'sec.names' option is now deprecated, as br.sample() now gives only a single time series.")

    if(!is.null(empty.sec))
        stop("'empty.sec' option is now deprecated, as br.sample() now gives only a single time series.")

    if(!is.null(nsec))
        stop("'nsec' option is now deprecated, as br.sample() now gives only a single time series.\n",
             "Use 'br.hist(con=NULL, ...)' to simulate multiple securities.")

    if(!is.null(same.dates))
        stop("'same.dates' option is now deprecated. Use: 'rand.dates=FALSE'")

}

```


Time extension functions{#time.functions}
=========================================

Description
------------
Functions to get, set dates.

Usage
-----
    day(d)
    month(d)
    year(d)
    day(d, n)
    month(d, n)
    year(d, n)
    day(d)=x
    month(d)=x
    year(d)=x
    d %+% n
    d %-% n
    last.day(d)
    day.us(d1, d2)

Arguments
---------
d, d1, d2
:   objects of class date  

x
:   an integer representing the day/month/year  

n
:   an integer representing the months to add/subtract


Details
-------
If `component` is `day`, `month` or `year`: `component(d)` returns the *component* of the date `d` as an integer; `component(d, n)` returns the date `d` with the *component* set to the integer `n`; `component(d)= n` sets to the *component* of the date `d` to the integer `n`.  
`%+%` and `%-%` add and subtract months to a date.  
`last.day` returns last day of the month as an integer. `day.us` calculates date differences with the US convention.  


```{r time, opts.label='purlme'}
`%+%` <- function(x,y) UseMethod("%+%")
`%+%.Date` <- function(date,n) seq(date, by = paste (n, "months"), length = 2)[2]
`%-%` <- function(x,y) UseMethod("%-%")
`%-%.Date` <- function(date,n) seq(date, by = paste (-n, "months"), length = 2)[2]

year=function(d, n=NULL){
    if(is.null(n)) d=as.numeric(format(d, "%Y")) else year(d)=n
    d    
}
`year<-`=function (d, value) d <-as.Date(paste0(value, format(d, "-%m-%d")))

month=function(d, n=NULL){
    if(is.null(n)) d=as.numeric(format(d, "%m")) else month(d)=n
    d 
}
`month<-`=function (d, value) d <-as.Date(paste0(format(d, "%Y-"),  value, format(d, "-%d")))

day=function(d, n=NULL){
    if(is.null(n)) d=as.numeric(format(d, "%d")) else day(d)=n
    d 
}
`day<-`=function (d, value) d <-as.Date(paste0(format(d, "%Y-%m-"),  value))

last.day=function(d){
    x=d %+% 1 #add a month
    day(x)=1  #set to 1st
    day(x-1)  #get day before
}

day.us=function(d1, d2){
    #set to first of month
    x1=day(d1,1);x2=day(d2,1);
    x=seq(x1, x2, by="1 month")
    #last day of each month in seq
    x=sapply(x, last.day)
    #count 31d-months
    x=length(which(x>30))
    #substract 1 for each 31d-month
    as.numeric(d2-d1-x)
}

store(day)
store(month)
store(year)
store(`day<-`)
store(`month<-`)
store(`year<-`)
store(`%+%`)
store(`%-%`)
store(`%+%.Date`)
store(`%-%.Date`)
store(last.day)
store(day.us)

```



```{r topics, purl=FALSE, eval=TRUE, include=FALSE}
read.head=function(rmdfile) {x=readLines(rmdfile); x[grep("^=+", x)-1]}
topics=function(rmdfile, mdfile){
    x=read.head(rmdfile)
    x=sub("\\{", "]\\(", x )
    x=sub("\\}", "\\)", x )
    idx=paste0("[", x, "   ")
    idx=c("R topics documented:", "-----------", idx)
    txt=readLines(mdfile)
    first=grep(".", txt)[1]
    txt=c(txt[first], idx, txt[(first+1):length(txt)])
    writeLines(txt, mdfile)
#    c(txt[first], idx,  txt[(first+1):(first+4)])
}


```

```{r parseargs, purl=FALSE, eval=TRUE, include=FALSE}

## HQ means hash-quote. The symbol is used to avoid detecting it as a real comment  
## HQ comments are copied to the above HQ @args tag
## Inner/Outer HQ require one or more space after.
## Outer HQ comments do not want a blank line following, but:
##    another HQ comment (continuing it), a standard comment, the argument.
##    However, standard comments cannot be in the be middle of outer HQ comments.
## Inner HQ comments should appear on line with a single arguments else only the first arg is parsed
## Tabs are not parsed as spaces currently. Avoid them.

parseargs=function(rmdfile, tmpfile){

    txt=readLines(rmdfile)
    HQ=paste0("#", "'")

    ## Outer HQ comments
    ## -----------------
    ocrex.loose=sprintf("^ *%s +", HQ)   #-> " *HQ +"
    ocrex=sprintf("%s+[^@]", ocrex.loose) #-> " *HQ ++[^@]", ++ need perl

    ## Test standard outer comments in the middle of HQ comments
    x= grep("^ *#[^']", txt)
    if(x[1]==1) x=x[-1]
    if(x[length(x)]==length(txt)) x=x[-length(x)]
    xx=lapply(x, function(xx) {
        if(grepl(ocrex, txt[xx-1], , perl=TRUE) &  grepl(ocrex, txt[xx+1], perl=TRUE)){        
            stop("Detected standard outer comments in the middle of HQ comments.\n",
                 paste(txt[xx+-1:1], collapse="\n" ))}    
    })


    ## Get outer arg comments
    ocomp= grep(ocrex, txt, perl=TRUE)
    ocom=txt[ocomp]
    ## debug 
    ## ocom=letters[1:9]
    ## ocomp=c(1, 3:6, 10, 21:23)

    ## Identify contiguos outer comments
    ccom=c(TRUE, diff(ocomp)!=1)

    ## Stack all to first of contiguos comments 
    ocomp2=NULL; ocom2=NULL
    for(i in seq_along(ocomp)){
        if(ccom[i]){
            pos=ocomp[i]
            ocomp2=c(ocomp2, pos)
            val=sub(ocrex.loose, '', ocom[i])
            ocom2=c(ocom2, val)
        } else {
            val=paste(val, sub(ocrex.loose, '', ocom[i]))
            ocom2[length(ocom2)]=val        
        }    
    }
    ocomp=ocomp2; ocom=ocom2

    ##  Get args lines after comments
    findAgs=function(pos){ # find non comment line postion, given outer HQ comment position 
        while(startsWith(trimws(txt[pos]), "#")) pos=pos+1
        pos
    }      
    ocomp.ags=sapply(ocomp, findAgs)
    ocom.ags=txt[ocomp.ags]

    ## Test blanks after HQ comments
    ocom.ags=trimws(ocom.ags)
    if(any(sapply(ocom.ags, nchar) == 0))
        stop("Some HQ outer comments are followed by blank lines")
              
    ## Parse args line  
    end=regexpr("[=,)]|$", ocom.ags)
    ocom.ags=substr(ocom.ags, 1, end-1) 


    ## Inner HQ comments
    ## -----------------
    icrex.loose=sprintf("[^ ]+ *%s ", HQ)   #-> "[^ ]+ *HQ "

    ## Get outer arg comments
    icomp= grep(icrex.loose, txt)
    icom=txt[icomp]

    ## Extract args
    end=regexpr("[=,#]", icom)
    icom.ags=substr(icom, 1, end-1) 
    icom.ags=trimws(icom.ags)
    icom=sub(paste0(".+", HQ, " +"), '', icom)


    ## Match @args tag
    ## ---------------
    acrex=sprintf(" *%s +@args", HQ)   #-> " *HQ +@args"
    
    ## Get @args positions
    acomp= grep(acrex, txt)

    ## Merge argument slots and HQ comments by position
    df=function(...) data.frame(..., stringsAsFactors=FALSE)

    m=merge(
        df(pos=ocomp, com=paste0(ocom.ags, "\n:   ", ocom)),
        df(pos=icomp, com=paste0(icom.ags, "\n:   ", icom)),
        suffixes=c('.out','.in'),
        by="pos", all=TRUE)

    m=merge(
        df(pos=acomp, apos=TRUE),
        m,
        by="pos", all=TRUE)
    
    m[2]=!is.na(m[2])
    m[is.na(m)]=""
    m=df(m[1:2], com=apply(m[3:4], 1, paste, collapse=""))

    ## Split by comment by slots  and cat
    spl=rep(0, nrow(m))
    spl[m$apos] =  m$pos[m$apos]
    spl=cumsum(spl)
    spl=split(m$com, spl)
    spl=sapply(spl, function(x) paste(x[-1], collapse="\n\n"))


    ## Replace commment slots with comments 
    for(i in seq_along(acomp)){
        txt[acomp[i]] = spl[i]    
    }
    writeLines(txt,  tmpfile)
  
}
    
```

```{r attach, opts.label='purlme'}
### Make visible br.* in bloomr env and base ns
attach(bloomr)
rm(store)
```

```{r build, purl=FALSE, eval=FALSE, include=FALSE}
knitr:::opts_chunk$set(tidy.opts=list(width.cutoff=60))
knit2=function(file){
    require(knitr); require(rmarkdown)
    fse=tools:::file_path_sans_ext(file)
    step2=FALSE
    knit(file)
    parseargs(paste0(fse, '.Rmd'), paste0(fse, '.tmp.Rmd'))
    step2=TRUE
    knit(paste0(fse, '.tmp.Rmd'), output=paste0(fse, '.md'))
    topics(paste0(fse, '.Rmd'), paste0(fse, '.md'))
    render(paste0(fse, '.md'), "html_document")
    render(paste0(fse, '.md'), pdf_document())
    render("../README.md", html_document())
    unlink(paste0(fse, '.tmp.Rmd'))
    file.rename(paste0(fse, '.tmp.R'), paste0(fse, '.R')) 
}
knit2("bloomr.beta.Rmd")



## if with markdown lib, but topics needs rewrite
## shell("pandoc bloomr.md -o bloomr.pdf", shell=Sys.getenv("COMSPEC"))
## markdownToHTML("bloomr.md", "bloomr.html") 
## markdownToHTML("README.md", "README.html")

```

```{r unitests, purl=FALSE, eval=FALSE, include=FALSE}
con=br.open() 
br.bulk.tiks(con, c("MSFT US", "AMZN US"), addtype=TRUE)
br.bulk.idx(con, "SX5E Index", field="PX_LAST")
br.close(con) 
```


```{r moretests, purl=FALSE, eval=FALSE, include=FALSE}
# br.bdh(con, "MSFT US EQUITY", "PX_LAST", "20170202", "20170210", override_fields="PRICING_SOURCE", override_values="CG")
# br.bdh(con, "MSFT US EQUITY", "PX_LAST", "20170202", "20170210")

###=============
  


####
# debug(br.hist) ; br.hist(con, c("MSFT US Equity", "AMZN US Equity"), start="20170225")
#debug(br.hist.csv)
#debug(br.hist)
# br.hist.csv(NULL, "wei.csv", same.dates=TRUE, empty.sec=.2)
# br.bdh(con, "MSFT US Equity", start="20170225")
# source("newbulk3.R")

```



    
<!-- Local Variables: -->
<!-- mode: rmd -->
<!-- End: -->

<!--  LocalWords:  BloomR
 -->
