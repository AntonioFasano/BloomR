
```{r buildme, purl=FALSE, eval=FALSE, include=FALSE}

## First Step
## ----------
## First knit() to evaluate BloomR functions in order to run demos in Step2
##    BloomR functions are stored in chunks tagged with opts.label='brfuncs', and knitted only if step2=F
##    At the end of these chunks, functions are moved to "bloomr.time" enviroment by store().
## A new temp Rmd is created by parseargs() with descriptions of BloomR function arguments 
##    Argument descriptions are automatically generated from special tagged comments.
##
## Second Step
## -----------
## knit() of the temp Rmd to purl BloomR functions to bloomr.R/bloomr.beta.R generating literate output.
##    Purl happens via knit hook_purl.
##    "brfuncs" chunks are not evaluated, only  "demo*" tagged chunks containing example code for docs. 
##    Demo chunks are executed only if step2=T and thanks to functions evaluated in step1.
##    See "setup" chunk for definition of  "demo*" templates.
##    For beta code, source(".../bloomr.R") is usually required to execute step2. See "betaonly" chumk.

knit.twice=function(file) {
    fse <- tools:::file_path_sans_ext(file)
    step2=FALSE
    knitr::knit(file)
    parseargs(paste0(fse, '.Rmd'), paste0(fse, '.tmp.Rmd'))
    step2=TRUE
    knitr::knit(paste0(fse, '.tmp.Rmd'), output=paste0(fse, '.md'))
    topics(paste0(fse, '.Rmd'), paste0(fse, '.md'))
    rmarkdown::render(paste0(fse, '.md'), "html_document")
    rmarkdown::render(paste0(fse, '.md'), rmarkdown::pdf_document())
    #rmarkdown::render("../README.md", html_document())
    unlink(paste0(fse, '.tmp.Rmd'))
    
    file.rename(paste0(fse, '.tmp.R'), paste0(fse, '.R'))    
    ## fix a problem with purl commenting everything
    txt <- readLines(paste0(fse, ".R"))
    txt <- sapply(txt, function(line) sub("^#  ", "", line))
    writeLines(txt, paste0(fse, ".R"))
}
knit.twice("bloomr.time.Rmd")


## if with markdown lib, but topics needs rewrite
## shell("pandoc bloomr.md -o bloomr.pdf", shell=Sys.getenv("COMSPEC"))
## markdownToHTML("bloomr.md", "bloomr.html") 
## markdownToHTML("README.md", "README.html")

```



```{r setup, purl=FALSE, include=FALSE}

## debug
## rm(list=ls(all=TRUE)) 

### Chunk templates and defaults
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=60))
knitr::opts_chunk$set(echo=TRUE)
OTS=knitr::opts_template$set
## Step1 template: Load in memory and copy to bloomr(.beta).R BloomR functions
OTS(brfuncs=   list(purl=step2,  eval=!step2,   include=FALSE))
## Step2 templates: Run demos using Step1 functions
OTS(demofull= list(purl=FALSE, eval=step2,  include=TRUE))  # run w/ code + out   
OTS(demorun=  list(purl=FALSE, eval=step2,  include=TRUE, echo=FALSE)) # run w/ out, no code 
OTS(demodry=  list(purl=FALSE, eval=step2,  include=FALSE)) # run only (no code/out)
OTS(democode= list(purl=FALSE, eval=FALSE,  include=TRUE))  # show code only, no run  

## Purl hook
knitr::knit_hooks$set(purl = hook_purl)

```


```{r store, opts.label='brfuncs'}

## Purl this first
## Store br.* objects in bloomr env in base namespace
assign('bloomr.time', new.env(parent=asNamespace("stats")))


## func: store(func);  var: store("var")
store=function(sym) {
    if(is.function(sym)) {
        name=deparse(substitute(sym)) 
        val=sym
    } else {
        name=sym
        val=get(sym)
    }
    
    assign(name, val, envir=bloomr.time)
    rm( list=name, envir=parent.frame())
}

```

# BloomR time functions


Misc functions{#misc.functions}
==============================

Description
------------
`rm.all` deletes all objects (variables and functions) from memory, including invisible objects (those starting with a dot).
`rm.var` deletes non-function objects from memory.


Usage
-----
	rm.all()
	rm.var()
	

```{r miscfunc, opts.label='brfuncs'}

#Clean up
## Remove visible and invisible objects
rm.all=function() 
    rm(list=ls(all=TRUE, envir=parent.frame()), envir=parent.frame())

## Remove visible non-function objects
rm.var=function() 
    rm(list=setdiff(ls(envir=parent.frame()), lsf.str(envir=parent.frame())),  envir=parent.frame())

store(rm.all)
store(rm.var)
```



Beta misc functions{#beta.misc.functions}
=========================================

Description
------------

Miscellaneous functions dealing with dates. 


Usage
-----
    br.try.date(d)
    br.is.same.class(...)


Arguments
---------
d
:   a POSIXlt, POSIXct, Date, "%Y/%m/%d", or "%Y-%m-%d" vector

Details
-------

`br.try.date` converts a vector to a date vector if possible or return `NULL`. Any vector element should be POSIXlt, POSIXct, Date, "%Y/%m/%d", or "%Y-%m-%d"

`br.is.same.class` check if all supplied argumets have the same class. It is mostly intended to check if dates are homogeneous. 


```{r MISCFUNC, opts.label='brfuncs'}

br.try.date=function(d){ # convert vector d to a date vector if possible or return null
### Any element should be POSIXlt, POSIXct, Date, "%Y/%m/%d", or "%Y-%m-%d"
                           
    if(identical(class(d), c("POSIXlt", "POSIXt"))) return(d) 
    if(identical(class(d), c("POSIXct", "POSIXt"))) return(d)
    if(identical(class(d), "Date")) return(d)

    if(is.character(d)) {
        
        try=as.Date(d, "%Y%m%d")
        if(!anyNA(try)) return(try)

        try=as.Date(d, "%Y/%m/%d")
        if(!anyNA(try)) return(try)

        try=as.Date(d, "%Y-%m-%d")
        if(!anyNA(try)) return(try)
    }
    
    return(NULL)
}

br.is.same.class=function(...){ # Check if all argumets have the same class
### Mostly intended to check if dates are homogeneous

    L=lapply(list(...), class)
    length(unique(L))==1
}


store(br.try.date)
store(br.is.same.class)


```



Time extension functions{#time.functions}
=========================================

Description
------------
Functions to get, set dates.

Usage
-----
    day(d)
    month(d)
    year(d)
    day(d, n)
    month(d, n)
    year(d, n)
    day(d)=x
    month(d)=x
    year(d)=x
    d %+% n
    d %-% n
    last.day(d)
    day.us(d1, d2)

Arguments
---------
d, d1, d2
:   objects of class date  

x
:   an integer representing the day/month/year  

n
:   an integer representing the months to add/subtract


Details
-------
If `component` is `day`, `month` or `year`: `component(d)` returns the *component* of the date `d` as an integer; `component(d, n)` returns the date `d` with the *component* set to the integer `n`; `component(d)= n` sets to the *component* of the date `d` to the integer `n`.  
`%+%` and `%-%` add and subtract months to a date.  
`last.day` returns last day of the month as an integer. `day.us` calculates date differences with the US convention.  


```{r time, opts.label='brfuncs'}
`%+%` <- function(x,y) UseMethod("%+%")
`%+%.Date` <- function(date,n) seq(date, by = paste (n, "months"), length = 2)[2]
`%-%` <- function(x,y) UseMethod("%-%")
`%-%.Date` <- function(date,n) seq(date, by = paste (-n, "months"), length = 2)[2]

year=function(d, n=NULL){
    if(is.null(n)) d=as.numeric(format(d, "%Y")) else year(d)=n
    d    
}
`year<-`=function (d, value) d <-as.Date(paste0(value, format(d, "-%m-%d")))

month=function(d, n=NULL){
    if(is.null(n)) d=as.numeric(format(d, "%m")) else month(d)=n
    d 
}
`month<-`=function (d, value) d <-as.Date(paste0(format(d, "%Y-"),  value, format(d, "-%d")))

day=function(d, n=NULL){
    if(is.null(n)) d=as.numeric(format(d, "%d")) else day(d)=n
    d 
}
`day<-`=function (d, value) d <-as.Date(paste0(format(d, "%Y-%m-"),  value))

last.day=function(d){
    x=d %+% 1 #add a month
    day(x)=1  #set to 1st
    day(x-1)  #get day before
}

day.us=function(d1, d2){
    #set to first of month
    x1=day(d1,1);x2=day(d2,1);
    x=seq(x1, x2, by="1 month")
    #last day of each month in seq
    x=sapply(x, last.day)
    #count 31d-months
    x=length(which(x>30))
    #substract 1 for each 31d-month
    as.numeric(d2-d1-x)
}

store(day)
store(month)
store(year)
store(`day<-`)
store(`month<-`)
store(`year<-`)
store(`%+%`)
store(`%-%`)
store(`%+%.Date`)
store(`%-%.Date`)
store(last.day)
store(day.us)

```



```{r topics, purl=FALSE, eval=TRUE, include=FALSE}
read.head=function(rmdfile) {x=readLines(rmdfile); x[grep("^=+", x)-1]}
topics=function(rmdfile, mdfile){
    x=read.head(rmdfile)
    x=sub("\\{", "]\\(", x )
    x=sub("\\}", "\\)", x )
    idx=paste0("[", x, "   ")
    idx=c("R topics documented:", "-----------", idx)
    txt=readLines(mdfile)
    first=grep(".", txt)[1]
    txt=c(txt[first], idx, txt[(first+1):length(txt)])
    writeLines(txt, mdfile)
#    c(txt[first], idx,  txt[(first+1):(first+4)])
}


```

```{r parseargs, purl=FALSE, eval=TRUE, include=FALSE}


parseargs <- function(rmdfile, tmpfile) {
## Generate a new tmp Rmd with BloomR function arguments descriptions.
##    These are embedded in comments preceding (or in line with) the arguments and detected via a magic prefix tag
## The magic tag is hash (#) followed by a quote ('), henceforth denoted as HQ. In fact, to avoid side effects,
##    I can't explicitly write the magic tag. 
## Description comments have the format "HQ comment...". They can be in line with or precede the related arguments.
##    Standalone desc comments (i.e. non-inline) should immediately precede their argument, i.e. no-blank lines.
##    To break long lines, you can stack standalone comments above the argument, again without blank lines in the middle.
## Once extracted from comments, the actual markdown description is written when a special placeholder is met.
##    The placeholder is "HQ @args". You are expected to insert it in the markdown following the function and 
##    it will be replaced with the descriptions extracted from the comments in the function definition
##    HQ tag is always followed by a space (not a tab). Pay attention to casual use to avoid side effects. 
## Here is an example (replace HQ tag with hash and quote): 
##    
##    foo
##    ===
##    An important function.
##     
##    Usage
##    ------
##        foo(x,y)
##     
##      
##    Arguments
##    ----------
##     
##    HQ @args
##       
##    ```{r foo OPTIONS}      
##    foo <- function(
##                    HQ This is an important argument, and
##                    HQ it deserves special attention.
##                    x,
##                    y  HQ That's important too.
##                    ){
##     
##        BODY
##    }
##    ```

    
    txt=readLines(rmdfile)
    HQ=paste0("#", "'")

    ## Outer HQ comments
    ## -----------------
    ocrex.loose=sprintf("^ *%s +", HQ)   #-> " *HQ +"
    ocrex=sprintf("%s+[^@]", ocrex.loose) #-> " *HQ ++[^@]", ++ need perl

    ## Test standard outer comments in the middle of HQ comments
    x= grep("^ *#[^']", txt)
    if(length(x)) {
        if(x[1]==1) x=x[-1]
        if(x[length(x)]==length(txt)) x=x[-length(x)]
        xx=lapply(x, function(xx) {
            if(grepl(ocrex, txt[xx-1], , perl=TRUE) &  grepl(ocrex, txt[xx+1], perl=TRUE)) {        
                stop("Detected standard outer comments in the middle of HQ comments.\n",
                     paste(txt[xx+-1:1], collapse="\n" ))}    
        })
    }
    
    ## Get outer arg comments
    ocomp= grep(ocrex, txt, perl=TRUE)
    ocom=txt[ocomp]
    ## debug 
    ## ocom=letters[1:9]
    ## ocomp=c(1, 3:6, 10, 21:23)

    ## Identify contiguos outer comments
    ccom=c(TRUE, diff(ocomp)!=1)

    ## Stack all to first of contiguos comments 
    ocomp2=NULL; ocom2=NULL
    for(i in seq_along(ocomp)) {
        if(ccom[i]) {
            pos=ocomp[i]
            ocomp2=c(ocomp2, pos)
            val=sub(ocrex.loose, '', ocom[i])
            ocom2=c(ocom2, val)
        } else {
            val=paste(val, sub(ocrex.loose, '', ocom[i]))
            ocom2[length(ocom2)]=val        
        }    
    }
    ocomp=ocomp2; ocom=ocom2

    ##  Get args lines after comments
    findAgs=function(pos) { # find non comment line postion, given outer HQ comment position 
        while(startsWith(trimws(txt[pos]), "#")) pos=pos+1
        pos
    }      
    ocomp.ags=unlist(sapply(ocomp, findAgs))
    ocom.ags=txt[ocomp.ags]

    ## Test blanks after HQ comments
    ocom.ags=trimws(ocom.ags)
    if(any(sapply(ocom.ags, nchar) == 0))
        stop("Some HQ outer comments are followed by blank lines")
              
    ## Parse args line  
    end=regexpr("[=,)]|$", ocom.ags)
    ocom.ags=substr(ocom.ags, 1, end-1) 

    if(is.null(ocom)) ocom <- ocomp <- character(0)
    
    ## Inner HQ comments
    ## -----------------
    icrex.loose=sprintf("[^ ]+ *%s ", HQ)   #-> "[^ ]+ *HQ "

    ## Get inner arg comments
    icomp= grep(icrex.loose, txt)
    icom=txt[icomp]

    ## Extract args
    end=regexpr("[=,#]", icom)
    icom.ags=substr(icom, 1, end-1) 
    icom.ags=trimws(icom.ags)
    icom=sub(paste0(".+", HQ, " +"), '', icom)


    ## Match @args tag
    ## ---------------
    acrex=sprintf(" *%s +@args", HQ)   #-> " *HQ +@args"
    
    ## Get @args positions
    acomp= grep(acrex, txt)

    ## Merge argument slots and HQ comments by position
    df <- data.frame

    if(length(ocom)) ocom <- paste0(ocom.ags, "\n:   ", ocom)
    if(length(icom)) icom <- paste0(icom.ags, "\n:   ", icom)
    m <- merge(
        df(pos=ocomp, com=ocom),
        df(pos=icomp, com=icom),
        suffixes=c('.out','.in'),
        by="pos", all=TRUE)

    apos <- if(length(acomp)) TRUE else acomp
    m <- merge(
        df(pos=acomp, apos=apos),
        m,
        by="pos", all=TRUE)
    
    m[2]=!is.na(m[2])
    m[is.na(m)]=""
    m=df(m[1:2], com=apply(m[3:4], 1, paste, collapse=""))

    ## Split by comment by slots  and cat
    spl=rep(0, nrow(m))
    spl[m$apos] =  m$pos[m$apos]
    spl=cumsum(spl)
    spl=split(m$com, spl)
    spl=sapply(spl, function(x) paste(x[-1], collapse="\n\n"))


    ## Replace commment slots with comments 
    for(i in seq_along(acomp)){
        txt[acomp[i]] = spl[i]    
    }
    writeLines(txt,  tmpfile)
  
}
    
```

```{r attach, opts.label='brfuncs'}
### Make visible br.* in bloomr env and base ns
attach(bloomr.time)
rm(store)
rm(bloomr.time)
```
 

    
<!-- Local Variables: -->
<!-- mode: rmd -->
<!-- End: -->

<!--  LocalWords:  BloomR
 -->
